---
title: "A Starting Guide for aglm"
author: "Kenji Kondo"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{start-aglm}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```


## Introduction

not provided yet

## Installation

To install the latest version from `github` :
```{r, eval=FALSE}
install.packages("devtools")
devtools::install_github("kkondo1981/aglm", build_vignettes=TRUE)
```

## Quick Start

The purpose of this section is to give users a general understanding of aglm package and its usage.

### Load Package

First, we need to load aglm package.

```{r}
library(aglm)
```

### Experimental Settings

Next, we demonstrate how we can easily do predictive modeling for non-linear datasets using `aglm` package.
To show `aglm` package can handle both quantitative data (as integer or numeric) and qualitative data (as character and factor), we generate two types of variables named `quan_var` and `qual_var` randomly as following:

```{r}
# size of observations
nobs <- 500

# Randomly generates a numeric vector (as quantitative data)
quan_var <- matrix(runif(nobs), ncol=1)
colnames(quan_var) <- "quan_var"

# Randomly generates a character vector (as qualitative data with 5 levels)
qual_var <- matrix(paste0("level_", sample(1:5, nobs, replace=TRUE)), ncol=1)
colnames(qual_var) <- "qual_var"
```

And we also generate a numeric vector `y` from `quan_var` and `qual_var` as following:

```{r}
# Generates non-linear reponse
y <- sign(quan_var) * (abs(quan_var) ** 4) * (qual_var != "level_1")
y <- y + 0.1 * rnorm(length(y))
plot(quan_var, y)
```

Note that `aglm` package can handle multi-dimensional data (for example `ncol=10` or `ncol=100` cases are also OK).
However, usages of `aglm` are not different dipending on dimensions of data, so we use one-dimensional vectors as input data here.


### Predictive Variables

In the latter of this section, we use `quan_var` and `qual_var` as predictive variables (or explanatory variables), and demonstrates a regression problem of infer the relationship between the response variable `y` and predictive variables, using `aglm` package.

In `aglm` package, predictor variables are represented by an object of class named `PredVars`.
The reason why such a special purpose class exists is that `aglm` package doesn't use input data directly but pre-processes them before inference steps to improve accuracy, and therefore need to hold some attributes related with how each predictive variable should be treated internally.

Creations of `PredVars` objects are straightforward.
We can create a new PredVars object by calling `newPredVars` function as follows.

```{r}
predVars <- newPredVars(x=quan_var, x_UD=qual_var)
```

As seen in above codes, we can pass quantitative data and qualitative data separetly, through two different arguments named `x` and `x_UD`. 
(For your informaton, "UD" in `x_UD` is an abbreviation of the word "Unordered Dummy" and derived from internal representations of qualitative data. See [Appendix 0: How predictor variables are treated by aglm])

Moreover, we introduce that there exists other ways to achive same results as above codes as below.

```{r, eval=FALSE}
## Combine all predictive variables into one multi-dimensional data frame
x_all <- data.frame(quan_var, qual_var)

## Each of following three statement has the same meaning as `predVars <- newPredVars(x=quan_var, x_UD=qual_var)` in this case

# Way 1: The 2nd column is qualitative and others are quantitative
predVars <- newPredVars(x=x_all, UD_vars=2) 

# Way 2: The column named "qual_var" is qualitative and others are quantitative
predVars <- newPredVars(x=x_all, UD_vars="qual_var")  

# Way 3: Columns with type `character` and `factor` are treated as qualitative and others are treated as quantitative
predVars <- newPredVars(x=x_all)  
```

Note that the abovementioned creation step can be omitted in practice.
Because fitting and predicting funtions of `aglm` package have a feature to convert input data into a `PredVars` object internally if other types of data are given, users usually do not need to care about `PredVars` objects.
However, we believed that it is quite helpful for understanding `aglm` package, to know how input data are handled by `aglm` package.

As a final step of this section, let's see the structure of the a `PredVars` object.

```{r}
str(predVars)
```

First of all, we can see a `PredVars` object has two slots (or members) named `vars_info` and `data`, and may notice that the `data` slot is just a data.frame object which contains entire data given as predictor variables.

Next, please be aware that `vars_info` slot consists of three lists of different lengths and each of them has three common attributes named `idx`, `name`, `type`.

From a conclusion, each one of these three lists represents one predictive variable, and `idx`, `name`, and `type` are a serial number of the variable, a name of the variable, and a type of the variable ("O": ordered=quantitative, "U": unordered=qualitative, "I": interaction) respectively.

It might be strange that there are three lists corresponding three predictive variables although we give only two predictive variables named `quan_var` and `qual_var`.
It's because that `newPredVars` function automatically adds `nvar * (nvar - 1) / 2` predicive variables (where `nvar` is the number of given predictive variables) cooresponding to interaction effects for all the pairs of given predictive variables as its default behaviour.
In this case, the interaction between `quan_var` and `qual_var` is added as the third element of `vars_info`.
Of course, you can stop this default behaviour by setting `append_interactions_vars=FALSE` when calling `newPredVars` function.

Note that these informations stored in `vars_info` are kinds of metadata and not predictive variables' data themself.
The acutual data is stored in the `data` slot and `vars_info` are used by `aglm` package for converting `data` into the internal representations of predictive variables when executing fitting and predicting.
See [Appendix 0: How predictor variables are treated by aglm] for more details about this topic.


### Fitting A Model

Fitting data is straightforwad by using `aglm` function as:

```{r}
fitted <- aglm(x=predVars, y=y, lambda=0.1)
```

The returned value of `aglm` function is an object of `AccurateGLM` class.

```{r}
class(fitted)
```

As mentioned above, we can ommit to create `PredVars` object manually as:

```{r, eval=FALSE}
fitted <- aglm(x=quan_var, x_UD=qual_var, y=y, lambda=0.1)
```

The `lambda` option specifies the coefficient of regularization term in the loss function, and `aglm` function examined multiple different values if `lambda` is not explicitly given.
This behaviour is as same as `glmnet` function of `glmnet` package because the `aglm` function currently uses `glmnet` as its backend and parameters not used by `aglm` function is directly passed to `glmnet` function.

Another example to pass parameters to control `glmnet` function through `aglm` functions is as below:

```{r, eval=FALSE}
fitted <- aglm(x=predVars, y=y, lambda=0.1, maxit=100)
```

Furthermore, we can get fitted `glmnet` object by using `backend_models` slot of the return value of `aglm` function:

```{r}
fitted <- aglm(x=predVars, y=y)
plot(fitted@backend_models[[1]])
```

However, using `backend_models` slots directly is not recommended because of no future warranty, and a better way is to use generic utility functions for class `AccurateGLM` as following:

```{r}
plot(fitted)
```

See the help documents of `plot.AccurateGLM`, `deviance.AccurateGLM`, and `coef.AccurateGLM` for more details of these utility functions.


### Predicting for New Data

We generate another random dataset to demonstrate predictions for new data.

```{r}
# size of observations
n_new_obs <- 100

# Generates new predictive variables
new_quan_var <- matrix(runif(n_new_obs), ncol=1); 
colnames(new_quan_var) <- "quan_var"
new_qual_var <- matrix(paste0("level_", sample(1:5, n_new_obs, replace=TRUE)), ncol=1)
colnames(new_qual_var) <- "qual_var"
```

And predicting for these new predictive variables by `predict` function as follows:

```{r}
fitted <- aglm(x=quan_var, x_UD=qual_var, y=y, lambda=1e-6)
y_pred <- predict(fitted, newx=new_quan_var, newx_UD=new_qual_var)
```

We use relatively small lambda (1e-5) because large lambda doesn't work in this case. (Maybe there are not so many predictive variables in our experiments and regularization with lambda is too much in this case.)
In general cases, see [Cross Validation to Choose lambda] to lean how to choose lambda appropriately.

Now we can see the following plot to compare predicted relationship between `y` and `new_quan_var` with true one.
The black points are predicted ones and the red points are true ones (without gaussian noises).
Be aware that the non-linear structure of the data seems captured by `aglm`.

```{r}
# Generates non-linear reponse
y_true <- sign(new_quan_var) * (abs(new_quan_var) ** 4) * (new_qual_var != "level_1")

plot(new_quan_var, y_pred)
points(new_quan_var, y_true, col="red")
```

For comparison, we show the result of a normal GLM case here.
As plotted below, a normal GLM with gaussian family and identity link can't capture non-linearity of this problem without any device. 

```{r}
library(glmnet)

# add a column of zero vector to avoid error occurs if x has only one column.
x <- cbind(quan_var, 0)
newx <- cbind(new_quan_var, 0)

# fitting GLM with gaussian family and identity link
fitted <- glmnet(x=x, y=y, lambda=1e-6)

# compare predictions of normal GLM and true y
y_pred <- predict(fitted, newx=cbind(new_quan_var, 0))
y_true <- sign(new_quan_var) * (abs(new_quan_var) ** 4) * (new_qual_var != "level_1")
plot(new_quan_var, y_pred)
points(new_quan_var, y_true, col="red")
```

## non-Gaussian Models

not provided yet

## Cross Validation to Choose lambda

not provided yet


## Appendix 0: How predictor variables are treated by aglm

not provided yet
